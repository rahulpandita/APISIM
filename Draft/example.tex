\section{Examples}
\label{sec:example}

We next present an example to motivate our work and list the considerations for applying text mining techniques on API documents. 
This example is from real Java Platform, Micro Edition (JME) formerly known as J2ME and Android API. Both J2ME and Android use Java as the language of implementation and targeted towards hand-held devices. However, our approach is independent of language of implementation and thus can be used for any similar source and target API.  


\begin{figure}
	\begin{framed}
		\begin{small}
			\CodeIn{public void drawString(String str,int x,int y,int anchor)}\\
			Draws the specified String using the current font and color. The x,y position is the position of the anchor point. See anchor points.\\
			\textbf{Parameters}\\
			\textit{str} - the String to be drawn\\
			\textit{x} - the x coordinate of the anchor point\\
			\textit{y} - the y coordinate of the anchor point\\
			\textit{anchor} - the anchor point for positioning the text\\
			\textbf{Throws}\\
			\textit{NullPointerException} - if str is null\\
			\textit{IllegalArgumentException} - if anchor is not a legal value\\
			\textbf{See Also}\\
			\CodeIn{drawChars(char[], int, int, int, int, int)}\\
		\end{small}
	\end{framed}
	\caption{drawString method of Graphics class in J2ME}
	\label{fig:drawStringJavadoc}
\end{figure}



\begin{figure}
	\begin{framed}
		\begin{small}
			\CodeIn{public void drawText (String text, float x, float y, Paint paint)}\\
			Draw the text, with origin at (x,y), using the specified paint. The origin is interpreted based on the Align setting in the paint.\\
			\textbf{Parameters}\\
			\textit{text} - The text to be drawn\\
			\textit{x} - The x-coordinate of the origin of the text being drawn\\
			\textit{y} - The y-coordinate of the origin of the text being drawn\\
			\textit{paint} - The paint used for the text (e.g. color, size, style)\\
		\end{small}
	\end{framed}
	\caption{drawText method of Canvas class in Android}
	\label{fig:drawTextJavadoc}
\end{figure}


Figure~\ref{fig:drawStringJavadoc} shows the API method description of \CodeIn{drawString} method from J2ME API.
Figure~\ref{fig:drawTextJavadoc} shows the API method description of the Android API equivalent method \CodeIn{drawText}.
Notice the overlap in the language of these two methods.
From a human perspective its easier to conclude that the two methods offer similar
functionality after reading the descriptions.
However, there are lot of intermediate steps to reach that conclusion.
For instance, Android API has more than 23,000 public methods.
Manually going through each method description is impractical.
Provided we are given a keyword based search framework (a very basic text mining infrastructure) for querying the Android API method descriptions, the next step is: \textit{what does the query look like?}.

Table~\ref{tab:exampleQueries} lists some of the queries we tried on an index of Android API method descriptions to find a mapping for the J2ME method \CodeIn{drawString} shown in Figure~\ref{fig:drawStringJavadoc}. 
Column ``Query'' describes the query we executed on the index. Column ``Hits'' lists the number of matches found, and Column ``Relevant 10'' lists the rank of the first relevant method in top ten results. For instance, when we searched for the class name ``Graphics'' in Android API we did not get any hits. We also did not get any hits for when we searched for method name ``drawString''. 

When we searched for the method signatures we got a 23,547 hits (almost all methods in Android API), mostly because of the confounding effects of keywords such as ``public''. Most of the methods signatures will have the keyword ``public''. 
Although the ranking mechanism did push methods with most keyword matches first, we did not find a relevant method in top 10.
Likewise the method descriptions as a whole or in parts also did not yield better results.
In this case a combination of various attributes such as method name split in camel case, keywords from class description and method description resulted in the Android API equivalent method \CodeIn{drawText} shown in Figure~\ref{fig:drawTextJavadoc} in the top ten results.

 \begin{table}
	\begin{center}
		\caption{Query Results}
		\begin{small}
			\begin{tabular}{rlrr}
				\topline
				\headcol 	S No. 	& Query	& Hits & Relevant 10\\
				\midline 
				
				\rowpln 1	& Class Name: ``Graphics''					& 0 & -\\
				\rowcol 2	& Method Name: ``drawString''				& 0 & -\\
				\rowcol 3	& Method Signature							& 23547 & - \\
				\rowpln 4	& Method Description: (Complete)			& 16820 & \\
				\rowcol 5	& Method Description: (summary sentences)	& 94230 & - \\
				\rowpln 6	& Combination								& 1479 & 3 \\			
				\bottomline
				%----------------- END TABLE DATA ------------------------ 
			\end{tabular}
			\label{tab:exampleQueries}
		\end{small}
		
	\end{center}
\end{table}


The examples demonstrates difficulties faced by simple keyword-based searches and text mining in general to find likely method mappings. In general, there are following difficulties in applying text mining approaches to API documents :
 
\begin{enumerate}
		
	\item \textit{Confounding effects}. Certain method names have an confounding effects. For instance \CodeIn{toString()}, \CodeIn{get()}, \CodeIn{set()} are too generic and tend to have similar descriptions across different method definitions. These generic methods often cause interference with the output of text mining based approaches.
	
	\item \textit{Weights}. Not all terms in a method descriptions are equally important keywords. For instance, the term ``zip'' in the sentence ``opens a zip file'' is more important than the terms ``opens'' and ``files'' as the term empathizes on the specific type of file. The problem is to automatically identify the importance of a term.
	
	\item \textit{Structure}. API documents are not flat contiguous text blobs. They often have well defined structure, that is often shared by method descriptions. Ignoring the structure may cause ineffective queries negatively affecting the results. This is addressed by querying individual elements (such as class description, class names, method names, method descriptions) and then aggregate the results. The problem is to effectively aggregate the results.
			
	
\end{enumerate}
